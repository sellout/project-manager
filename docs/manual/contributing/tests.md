# Tests {#sec-tests}

Project Manager includes a basic test suite and it‘s highly recommended to include at least one test when adding a module. Tests are typically in the form of “golden tests“ where, for example, a generated configuration file is compared to a known correct file.

It‘s relatively easy to create tests by modeling the existing tests, found in the `tests` project directory.

## Writing Basic Tests {#sec-tests-basic}

Project Manager tests use the [NMT](https://git.sr.ht/~rycee/nmt) framework, which provides a set of assertion functions to verify that modules generate the expected files and configurations. Tests are written as Nix expressions that define both the Project Manager configuration and the test assertions.

### Test Structure {#sec-tests-structure}

A basic test file structure looks like:

```nix
{
  # Project Manager configuration
  programs.myprogram = {
    enable = true;
    settings = {
      option = "value";
    };
  };

  # NMT test script with assertions
  nmt.script = ''
    assertFileExists "project-files/.config/myprogram/config.toml"
    assertFileContent "project-files/.config/myprogram/config.toml" ${./expected-config.toml}
  '';
}
```

### Test Organization {#sec-tests-organization}

Tests are kept alongside the module they’re testing:

```
modules/programs/git
├── default.nix            ← the module itself
└── tests
    ├── default.nix        ← an attrSet of test cases
    ├── enabled            ← a single test case
    │   ├── default.nix    ← the configuration being tested & assertions
    │   ├── .gitattributes ←─╮
    ┊   └── gitignore      ← expected output files
```

**NB**: Many tests involve multiple modules, but generally one module is clearly the one that’s being tested (for example, adding `programs.git.enable = true;` to a test case isn’t a test of the `git` module, but a test that the other module configured in the test case behaves correctly when `git` is enabled). Think about which module the logic you’re testing is in, and that’s likely where the test belongs.

The `…/tests/default.nix` file should list all test cases:

```nix
{
  myprogram-basic-configuration = ./basic-configuration;
  myprogram-empty-settings = ./empty-settings;
}
```

### Common NMT Assertions {#sec-tests-assertions}

NMT provides several assertion functions:

- `assertFileExists "path"` - Verify a file was created
- `assertPathNotExists "path"` - Verify a file WASN’T created
- `assertFileContent "path" expected-file` - Compare file contents
- `assertFileRegex "path" "regex"` - Check file matches regex

For a full reference to the functions available in test scripts, you can look at NMT's
[bash-lib](https://git.sr.ht/~rycee/nmt/tree/master/item/bash-lib).

### Practical Examples {#sec-tests-examples}

Here are some real-world examples of common test patterns:

**Testing that a configuration file is generated:**

```nix
{
  programs.alacritty = {
    enable = true;
    settings.font.size = 12;
  };

  nmt.script = ''
    assertFileExists "project-files/.config/alacritty/alacritty.yml"
    assertFileContains "project-files/.config/alacritty/alacritty.yml" "size: 12"
  '';
}
```

**Testing that no files are created when disabled:**

```nix
{
  programs.alacritty.enable = false;

  nmt.script = ''
    assertPathNotExists "project-files/.config/alacritty"
  '';
}
```

**Testing exact file content against expected output:**

```nix
{
  programs.fastfetch = {
    enable = true;
    settings.display.color = "blue";
  };

  nmt.script =
    let
      configFile = "project-files/.config/fastfetch/config.jsonc";
    in
    ''
      assertFileExists "${configFile}"
      assertFileContent "${configFile}" ${./expected-config.jsonc}
    '';
}
```

**Testing multiple conditions in one test:**

```nix
{
  programs.myprogram = {
    enable = true;
    configFile = "custom.conf";
    extraConfig = "debug = true";
  };

  nmt.script = ''
    assertFileExists "project-files/.config/myprogram/custom.conf"
    assertFileRegex "project-files/.config/myprogram/custom.conf" "debug = true"
    assertFileRegex "project-files/.config/myprogram/custom.conf" "^# Generated by Project Manager"
  '';
}
```

### Platform-Specific Tests {#sec-tests-platform-specific}

When a module is platform-specific (Linux-only or Darwin-only), the test's `default.nix` file should use `lib.optionalAttrs` to conditionally expose tests based on the platform. This prevents evaluation errors on unsupported platforms during the test suite runs.

**Linux-only module tests:**

```nix
{ lib, pkgs, ... }:

lib.optionalAttrs pkgs.stdenv.hostPlatform.isLinux {
  rofi-valid-config = ./valid-config.nix;
  rofi-custom-theme = ./custom-theme.nix;
}
```

**Darwin-only module tests:**

```nix
{ lib, pkgs, ... }:

lib.optionalAttrs pkgs.stdenv.hostPlatform.isDarwin {
  sketchybar-basic = ./basic-configuration.nix;
  sketchybar-lua-config = ./lua-config.nix;
}
```

For cross-platform modules that have packages which need to be stubbed on Darwin, add the package names to `tests/darwinScrublist.nix` to prevent build failures during cross-platform test runs.

## Using the tests command {#sec-tests-command}

Project Manager provides a convenient `tests` command for discovering and running tests:

```shell
# List all available tests
$ nix run .#tests -- -l

# List tests matching a pattern
$ nix run .#tests -- -l alacritty

# Run all tests matching a pattern
$ nix run .#tests -- alacritty

# Run a specific test
$ nix run .#tests -- test-alacritty-empty-settings

# Run integration tests
$ nix run .#tests -- -t -l

# Interactive test selection
$ nix run .#tests

# Pass additional nix build flags
$ nix run .#tests -- alacritty -- --verbose
```

## Manual test commands {#sec-tests-manual}

For advanced usage or CI environments, you can also run tests manually using nix build commands.

The full Project Manager test suite can be run by executing

```shell
$ nix-build --pure --option allow-import-from-derivation false testing -A build.all
```

in the project root. List all test cases through

```shell
$ nix-build --pure testing --option allow-import-from-derivation false -A list
```

and run an individual test, for example `alacritty-empty-settings`, through

```shell
$ nix-build --pure testing --option allow-import-from-derivation false -A build.alacritty-empty-settings
```

However, those invocations will impurely source the system’s Nixpkgs, and may cause failures. To run against the Nixpkgs from the `flake.lock` file, use instead for example

```shell
$ nix build --reference-lock-file flake.lock --option allow-import-from-derivation false ./testing#test-all
```

or

```shell
$ nix build --reference-lock-file flake.lock --option allow-import-from-derivation false ./tests#test-alacritty-empty-settings
```

## Debugging tests {#sec-tests-debugging}

If you run an individual test, the contents will be in `./result/tested/`. This may help you figure out what happened (for example, did a file get written to an unexpected directory).
